!::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
!
!    This file is part of ICTP RegCM.
!
!    ICTP RegCM is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    ICTP RegCM is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with ICTP RegCM.  If not, see <http://www.gnu.org/licenses/>.
!
!::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

module mod_pbl_holtbl
  !
  ! Holtslag planetary boundary layer scheme
  ! Reference : Holtslag, De Bruijn and Pan - MWR - 8/90
  !
  use mod_intkinds
  use mod_realkinds
  use mod_dynparam
  use mod_runparams , only : iqv , iqc , dt , rdt , ichem , ichdrdepo ,    &
          dsigma , zhnew_fac , ifaholtth10 , ifaholtmax , ifaholtmin
  use mod_mppparam
  use mod_memutil
  use mod_service
  use mod_mpmessage
  use mod_pbl_common
  use mod_regcm_types

  implicit none

  private

  public :: allocate_mod_pbl_holtbl , holtbl

  real(rk8) , pointer , dimension(:,:,:) :: vv , cgh , kvc , kvh ,   &
                                          kvm , kvq ! , cgq
  real(rk8) , pointer, dimension(:,:) :: hfxv , obklen , th10 , &
                                       ustr , xhfx , xqfx , pfcor
!
  real(rk8) , pointer , dimension(:,:,:) :: alphak , betak , &
                        coef1 , coef2 , coef3 , coefe , coeff1 , &
                        coeff2 , tpred1 , tpred2
  real(rk8) , pointer , dimension(:,:,:) :: kzm , rc , ttnp
  real(rk8) , pointer , dimension(:,:) :: govrth , uvdrage
  real(rk8) , pointer , dimension(:) :: hydf
!
  real(rk8) , pointer , dimension(:,:,:) :: dza , thvx
  real(rk8) , pointer , dimension(:,:,:) :: akzz1 , akzz2
  real(rk8) , pointer , dimension(:,:,:) :: rhohf
!
  real(rk8) , pointer , dimension(:,:,:) :: ri
  real(rk8) , pointer , dimension(:,:) :: therm
!
! minimum eddy diffusivity
  real(rk8) , parameter :: kzo = d_one
  real(rk8) , parameter :: szkm = 1600.0D0
! coef. of proportionality and lower % of bl in sfc layer
  real(rk8) , parameter :: fak = 8.5D0
  real(rk8) , parameter :: sffrac = 0.1D0
! beta coefs. for momentum, stable conditions and heat
  real(rk8) , parameter :: betam = 15.0D0
  real(rk8) , parameter :: betas = 5.0D0
  real(rk8) , parameter :: betah = 15.0D0
  real(rk8) , parameter :: mult = 0.61D0
  real(rk8) , parameter :: ccon = fak*sffrac*vonkar
  real(rk8) , parameter :: gvk = egrav*vonkar
  real(rk8) , parameter :: gpcf = egrav/d_1000 ! Grav and pressure conversion
  real(rk8) , parameter :: binm = betam*sffrac
  real(rk8) , parameter :: binh = betah*sffrac
! power in formula for k and critical ri for judging stability
  real(rk8) , parameter :: pink = d_two
!
  contains
!
  subroutine allocate_mod_pbl_holtbl
    implicit none

    call getmem3d(alphak,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:alphak')
    call getmem3d(betak,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:betak')
    call getmem3d(coef1,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:coef1')
    call getmem3d(coef2,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:coef2')
    call getmem3d(coef3,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:coef3')
    call getmem3d(coefe,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:coefe')
    call getmem3d(coeff1,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:coeff1')
    call getmem3d(coeff2,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:coeff2')
    call getmem3d(tpred1,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:tpred1')
    call getmem3d(tpred2,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:tpred2')
    call getmem3d(ri,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:ri')
    call getmem3d(kzm,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:kzm')
    call getmem3d(rc,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:rc')
    call getmem3d(ttnp,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:ttnp')
    call getmem2d(govrth,jci1,jci2,ici1,ici2,'mod_holtbl:govrth')
    call getmem1d(hydf,1,kz,'mod_holtbl:hydf')
    call getmem2d(therm,jci1,jci2,ici1,ici2,'mod_holtbl:therm')
    call getmem3d(vv,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:vv')
    call getmem3d(cgh,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:cgh')
    call getmem3d(kvh,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:kvh')
    call getmem3d(kvm,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:kvm')
    call getmem3d(kvq,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:kvq')
    call getmem2d(hfxv,jci1,jci2,ici1,ici2,'mod_holtbl:hfxv')
    call getmem2d(pfcor,jci1,jci2,ici1,ici2,'mod_holtbl:pfcor')
    call getmem2d(obklen,jci1,jci2,ici1,ici2,'mod_holtbl:obklen')
    call getmem2d(th10,jci1,jci2,ici1,ici2,'mod_holtbl:th10')
    call getmem2d(ustr,jci1,jci2,ici1,ici2,'mod_holtbl:ustr')
    call getmem2d(xhfx,jci1,jci2,ici1,ici2,'mod_holtbl:xhfx')
    call getmem2d(xqfx,jci1,jci2,ici1,ici2,'mod_holtbl:xqfx')
    call getmem3d(dza,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:dza')
    call getmem3d(rhohf,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:rhohf')
    call getmem2d(uvdrage,jci1-ma%jbl1,jci2, &
                          ici1-ma%ibb1,ici2,'mod_holtbl:uvdrage')
    call getmem3d(akzz1,jci1-ma%jbl1,jci2, &
                        ici1-ma%ibb1,ici2,1,kz,'mod_holtbl:akzz1')
    call getmem3d(akzz2,jci1-ma%jbl1,jci2, &
                        ici1-ma%ibb1,ici2,1,kz,'mod_holtbl:akzz2')
    call getmem3d(thvx,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:thvx')

    if ( ichem == 1 ) then
      call getmem3d(kvc,jci1,jci2,ici1,ici2,1,kz,'mod_holtbl:kvc')
    end if
  end subroutine allocate_mod_pbl_holtbl
!
  subroutine holtbl(m2p,p2m)
  implicit none
  type(mod_2_pbl) , intent(in) :: m2p
  type(pbl_2_mod) , intent(inout) :: p2m
  real(rk8) :: drgdot , kzmax , oblen , xps , ps2 , ri , &
             sf , sh10 , ss , uflxsf , uflxsfx , vflxsf ,     &
             vflxsfx
  integer(ik4) :: i , j , k , itr
#ifdef DEBUG
  character(len=dbgslen) :: subroutine_name = 'holtbl'
  integer(ik4) , save :: idindx = 0
  call time_begin(subroutine_name,idindx)
#endif
!
!----------------------------------------------------------------------
!
  ! decouple flux-form variables to give u,v,t,theta,theta-vir.,
  ! t-vir., qv, and qc at cross points and at ktau-1.
  !
  ! *** note ***
  ! the boundary winds may not be adequately affected by friction,
  ! so use only interior values of ubx3d and vbx3d to calculate
  ! tendencies.
  !
  do k = 1 , kz
    hydf(k) = gpcf/dsigma(k)
  end do
  do k = 1 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        thvx(j,i,k) = m2p%thatm(j,i,k)*(d_one+ep1*m2p%qxatm(j,i,k,iqv))
      end do
    end do
  end do
  !
  ! density at surface is stored in rhox2d, at half levels in rhohf.
  !
  do k = 1 , kzm1
    do i = ici1 , ici2
      do j = jci1 , jci2
        dza(j,i,k) = m2p%za(j,i,k) - m2p%za(j,i,k+1)
        xps = m2p%patm(j,i,k)
        ps2 = m2p%patm(j,i,k+1)
        rhohf(j,i,k) = (ps2-xps)/(egrav*dza(j,i,k))
      end do
    end do
  end do
  do i = ici1 , ici2
    do j = jci1 , jci2
      govrth(j,i) = egrav/m2p%thatm(j,i,kz)
    end do
  end do
!
! *********************************************************************
!
  !
  !   compute the vertical diffusion term:
  !
  do k = 2 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        rc(j,i,k) = 0.257D0*m2p%dzq(j,i,k)**0.175D0
      end do
    end do
  end do
  !
  !   compute the diffusion coefficient:
  !   blackadar scheme above boundary layer top
  !
  do k = 2 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        kzmax = 0.8D0*dza(j,i,k-1)*m2p%dzq(j,i,k)*rdt
        vv(j,i,k) = m2p%uxatm(j,i,k)*m2p%uxatm(j,i,k) + &
                    m2p%vxatm(j,i,k)*m2p%vxatm(j,i,k)
        ss = ((m2p%uxatm(j,i,k-1)-m2p%uxatm(j,i,k))*   &
              (m2p%uxatm(j,i,k-1)-m2p%uxatm(j,i,k))+   &
              (m2p%vxatm(j,i,k-1)-m2p%vxatm(j,i,k))*   &
              (m2p%vxatm(j,i,k-1)-m2p%vxatm(j,i,k)))/  &
              (dza(j,i,k-1)*dza(j,i,k-1)) + 1.0D-9
        ri = govrth(j,i)*(thvx(j,i,k-1)-thvx(j,i,k))/(ss*dza(j,i,k-1))
        if ( (ri-rc(j,i,k)) >= d_zero ) then
          kzm(j,i,k) = kzo
        else
          kzm(j,i,k) = kzo + dsqrt(ss)*(rc(j,i,k)-ri)*szkm/rc(j,i,k)
        end if
        kzm(j,i,k) = dmin1(kzm(j,i,k),kzmax)
      end do
    end do
  end do
!
! *********************************************************************
!
  !   holtslag pbl
  !
  !   initialize bl diffusion coefficients and counter-gradient terms
  !   with free atmosphere values and make specific humidity
  !
  do k = 2 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        ! eddy diffusivities for momentum, heat and moisture
        kvm(j,i,k) = kzm(j,i,k)
        kvh(j,i,k) = kzm(j,i,k)
        kvq(j,i,k) = kzm(j,i,k)
        if ( ichem == 1 ) then
          kvc(j,i,k) = kzm(j,i,k)
        end if
        ! counter gradient terms for heat and moisture
        cgh(j,i,k) = d_zero
      end do
    end do
  end do

  do i = ici1 , ici2
    do j = jci1 , jci2
      ! compute friction velocity
      uflxsfx = m2p%uvdrag(j,i)*m2p%uxatm(j,i,kz)
      vflxsfx = m2p%uvdrag(j,i)*m2p%vxatm(j,i,kz)
      ustr(j,i) = dsqrt(dsqrt(uflxsfx*uflxsfx+vflxsfx*vflxsfx)/m2p%rhox2d(j,i))
      ! convert surface fluxes to kinematic units
      xhfx(j,i) = m2p%hfx(j,i)/(cpd*m2p%rhox2d(j,i))
      xqfx(j,i) = m2p%qfx(j,i)/m2p%rhox2d(j,i)
      ! compute virtual heat flux at surface
      hfxv(j,i) = xhfx(j,i) + mult*m2p%thatm(j,i,kz)*xqfx(j,i)
      ! limit coriolis parameter to value at 10 deg. latitude
      pfcor(j,i) = dmax1(dabs(m2p%coriol(j,i)),2.546D-5)
    end do
  end do
  !
  !   estimate potential temperature at 10m via log temperature
  !   profile in the surface layer (brutsaert, p. 63).
  !   calculate mixing ratio at 10m by assuming a constant
  !   value from the surface to the lowest model level.
  !
  do i = ici1 , ici2
    do j = jci1 , jci2
      sh10 = m2p%qxatm(j,i,kz,iqv)/(m2p%qxatm(j,i,kz,iqv)+d_one)
      ! "virtual" potential temperature
      if ( hfxv(j,i) >= d_zero ) then
        th10(j,i) = thvx(j,i,kz)
      else
        ! first approximation for obhukov length
        if ( ifaholtth10 == 2 ) then
          th10(j,i) = (0.25D0*m2p%thatm(j,i,kz) + &
                       0.75D0*m2p%tgb(j,i))*(d_one+mult*sh10)
        else if ( ifaholtth10 == 3 ) then
          th10(j,i) = thvx(j,i,kz) + hfxv(j,i)/(vonkar*ustr(j,i)* &
                      dlog(m2p%za(j,i,kz)*d_r10))
        else
          th10(j,i) = ((m2p%thatm(j,i,kz) + &
                  m2p%tgb(j,i))*d_half)*(d_one+mult*sh10)
        end if
        oblen = -th10(j,i)*ustr(j,i)**3 /  &
                (gvk*(hfxv(j,i)+dsign(1.0D-10,hfxv(j,i))))
        if ( oblen >= m2p%za(j,i,kz) ) then
          th10(j,i) = thvx(j,i,kz) + hfxv(j,i)/(vonkar*ustr(j,i))*  &
             (dlog(m2p%za(j,i,kz)*d_r10)+d_five/oblen*(m2p%za(j,i,kz)-d_10))
        else if ( oblen < m2p%za(j,i,kz) .and. oblen > d_10 ) then
          th10(j,i) = thvx(j,i,kz) + hfxv(j,i)/(vonkar*ustr(j,i))*  &
              (dlog(oblen*d_r10)+d_five/oblen*(oblen-d_10)+         &
              6.0D0*dlog(m2p%za(j,i,kz)/oblen))
        else if ( oblen <= d_10 ) then
          th10(j,i) = thvx(j,i,kz) + hfxv(j,i)/(vonkar*ustr(j,i)) * &
                      6.0D0*dlog(m2p%za(j,i,kz)*d_r10)
        end if
      end if
      if ( ifaholtmax == 1 ) then
        th10(j,i) = dmax1(th10(j,i),m2p%tgb(j,i))  ! gtb add to maximize
      else  if ( ifaholtmin  == 1 ) then
        th10(j,i) = dmin1(th10(j,i),m2p%tgb(j,i))  ! gtb add to minimize
      end if
      ! obklen compute obukhov length
      obklen(j,i) = -th10(j,i)*ustr(j,i)**3 / &
              (gvk*(hfxv(j,i)+dsign(1.0D-10,hfxv(j,i))))
    end do
  end do
  !
  ! compute diffusivities and counter gradient terms
  !
  call blhnew(m2p,p2m)

  do k = 2 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        akzz1(j,i,k) = rhohf(j,i,k-1)*kvm(j,i,k)/dza(j,i,k-1)
      end do
    end do
  end do
  do k = 1 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        akzz2(j,i,k) = hydf(k)/m2p%psb(j,i)
      end do
    end do
  end do

  call exchange_lb(akzz1,1,jci1,jci2,ici1,ici2,1,kz)
  call exchange_lb(akzz2,1,jci1,jci2,ici1,ici2,1,kz)

  !
  !   calculate coefficients at dot points for u and v wind
  !
  do k = 2 , kz
    do i = idii1 , idii2
      do j = jdii1 , jdii2
        betak(j,i,k) = (akzz1(j-1,i,k)+akzz1(j-1,i-1,k)+ &
                        akzz1(j,i,k)  +akzz1(j,i-1,k))*d_rfour
      end do
    end do
  end do
  do k = 1 , kz
    do i = idii1 , idii2
      do j = jdii1 , jdii2
        alphak(j,i,k) = (akzz2(j-1,i,k)+akzz2(j-1,i-1,k)+ &
                         akzz2(j,i,k)  +akzz2(j,i-1,k))*d_rfour
      end do
    end do
  end do
!
! **********************************************************************
!
  ! start now procedure for implicit diffusion calculations
  ! performed separately for wind (dot points)
  ! and temperature and water vapor (cross points)
  ! countergradient term is not included in the implicit diffusion
  ! scheme its effect is included as in the old explicit scheme
  ! calculations assume fluxes positive upward, so the sign in front
  ! of uflxsf and vflxsf has been changed in the various terms
  !
  ! wind components
  !
  ! first compute coefficients of the tridiagonal matrix
  !
  ! Atmosphere top
  do i = idii1 , idii2
    do j = jdii1 , jdii2
      coef1(j,i,1) = dt*alphak(j,i,1)*betak(j,i,2)
      coef2(j,i,1) = d_one + dt*alphak(j,i,1)*betak(j,i,2)
      coef3(j,i,1) = d_zero
      coefe(j,i,1) = coef1(j,i,1)/coef2(j,i,1)
      coeff1(j,i,1) = m2p%udatm(j,i,1)/coef2(j,i,1)
      coeff2(j,i,1) = m2p%vdatm(j,i,1)/coef2(j,i,1)
    end do
  end do

  ! top to bottom
  do k = 2 , kz - 1
    do i = idii1 , idii2
      do j = jdii1 , jdii2
        coef1(j,i,k) = dt*alphak(j,i,k)*betak(j,i,k+1)
        coef2(j,i,k) = d_one+dt*alphak(j,i,k)*(betak(j,i,k+1)+betak(j,i,k))
        coef3(j,i,k) = dt*alphak(j,i,k)*betak(j,i,k)
        coefe(j,i,k) = coef1(j,i,k)/(coef2(j,i,k)-coef3(j,i,k)*coefe(j,i,k-1))
        coeff1(j,i,k) = (m2p%udatm(j,i,k) + &
                coef3(j,i,k)*coeff1(j,i,k-1)) / &
                (coef2(j,i,k)-coef3(j,i,k)*coefe(j,i,k-1))
        coeff2(j,i,k) = (m2p%vdatm(j,i,k) + &
                coef3(j,i,k)*coeff2(j,i,k-1)) / &
                (coef2(j,i,k)-coef3(j,i,k)*coefe(j,i,k-1))
      end do
    end do
  end do

  ! Nearest to surface
  uvdrage(jci1:jci2,ici1:ici2) = m2p%uvdrag
  call exchange_lb(uvdrage,1,jci1,jci2,ici1,ici2)

  do i = idii1 , idii2
    do j = jdii1 , jdii2
      coef1(j,i,kz) = d_zero
      coef2(j,i,kz) = d_one + dt*alphak(j,i,kz)*betak(j,i,kz)
      coef3(j,i,kz) = dt*alphak(j,i,kz)*betak(j,i,kz)
      drgdot = (uvdrage(j-1,i-1)+uvdrage(j,i-1) + &
                uvdrage(j-1,i)  +uvdrage(j,i))*d_rfour
      uflxsf = drgdot*m2p%udatm(j,i,kz)
      vflxsf = drgdot*m2p%vdatm(j,i,kz)
      coefe(j,i,kz) = d_zero
      coeff1(j,i,kz) = (m2p%udatm(j,i,kz)-dt*alphak(j,i,kz)*uflxsf+      &
                      coef3(j,i,kz)*coeff1(j,i,kz-1))/                  &
                     (coef2(j,i,kz)-coef3(j,i,kz)*coefe(j,i,kz-1))
      coeff2(j,i,kz) = (m2p%vdatm(j,i,kz)-dt*alphak(j,i,kz)*vflxsf+      &
                      coef3(j,i,kz)*coeff2(j,i,kz-1))/                  &
                     (coef2(j,i,kz)-coef3(j,i,kz)*coefe(j,i,kz-1))
    end do
  end do
  !
  !   all coefficients have been computed, predict field and put it in
  !   temporary work space tpred
  !
  do i = idii1 , idii2
    do j = jdii1 , jdii2
      tpred1(j,i,kz) = coeff1(j,i,kz)
      tpred2(j,i,kz) = coeff2(j,i,kz)
    end do
  end do

  do k = kz - 1 , 1 , -1
    do i = idii1 , idii2
      do j = jdii1 , jdii2
        tpred1(j,i,k) = coefe(j,i,k)*tpred1(j,i,k+1) + coeff1(j,i,k)
        tpred2(j,i,k) = coefe(j,i,k)*tpred2(j,i,k+1) + coeff2(j,i,k)
      end do
    end do
  end do
  !
  !   calculate tendency due to vertical diffusion using temporary
  !   predicted field
  !
  do k = 1 , kz
    do i = idii1 , idii2
      do j = jdii1 , jdii2
        p2m%uten(j,i,k) = p2m%uten(j,i,k) + &
                      (tpred1(j,i,k)-m2p%udatm(j,i,k))*rdt*m2p%psdot(j,i)
        p2m%vten(j,i,k) = p2m%vten(j,i,k) + &
                      (tpred2(j,i,k)-m2p%vdatm(j,i,k))*rdt*m2p%psdot(j,i)
      end do
    end do
  end do
  !
  !   Common coefficients.
  !
  do k = 1 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        alphak(j,i,k) = hydf(k)/m2p%psb(j,i)
      end do
    end do
  end do
  !
  !   temperature
  !   calculate coefficients at cross points for temperature
  !
  do k = 2 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        betak(j,i,k) = rhohf(j,i,k-1)*kvh(j,i,k)/dza(j,i,k-1)
      end do
    end do
  end do

  do i = ici1 , ici2
    do j = jci1 , jci2
      coef1(j,i,1) = dt*alphak(j,i,1)*betak(j,i,2)
      coef2(j,i,1) = d_one + dt*alphak(j,i,1)*betak(j,i,2)
      coef3(j,i,1) = d_zero
      coefe(j,i,1) = coef1(j,i,1)/coef2(j,i,1)
      coeff1(j,i,1) = m2p%thatm(j,i,1)/coef2(j,i,1)
    end do
  end do

  do k = 2 , kz - 1
    do i = ici1 , ici2
      do j = jci1 , jci2
        coef1(j,i,k) = dt*alphak(j,i,k)*betak(j,i,k+1)
        coef2(j,i,k) = d_one+dt*alphak(j,i,k)*(betak(j,i,k+1)+betak(j,i,k))
        coef3(j,i,k) = dt*alphak(j,i,k)*betak(j,i,k)
        coefe(j,i,k) = coef1(j,i,k)/(coef2(j,i,k)-coef3(j,i,k)*coefe(j,i,k-1))
        coeff1(j,i,k) = (m2p%thatm(j,i,k)+coef3(j,i,k)*coeff1(j,i,k-1)) / &
                      (coef2(j,i,k)-coef3(j,i,k)*coefe(j,i,k-1))
      end do
    end do
  end do

  do i = ici1 , ici2
    do j = jci1 , jci2
      coef1(j,i,kz) = d_zero
      coef2(j,i,kz) = d_one + dt*alphak(j,i,kz)*betak(j,i,kz)
      coef3(j,i,kz) = dt*alphak(j,i,kz)*betak(j,i,kz)
      coefe(j,i,kz) = d_zero
      coeff1(j,i,kz) = (m2p%thatm(j,i,kz) + &
              dt*alphak(j,i,kz)*m2p%hfx(j,i)*rcpd + &
              coef3(j,i,kz)*coeff1(j,i,kz-1)) / &
              (coef2(j,i,kz)-coef3(j,i,kz)*coefe(j,i,kz-1))
    end do
  end do
  !
  !   all coefficients have been computed, predict field and put it in
  !   temporary work space tpred
  !
  do i = ici1 , ici2
    do j = jci1 , jci2
      tpred1(j,i,kz) = coeff1(j,i,kz)
    end do
  end do

  do k = kz - 1 , 1 , -1
    do i = ici1 , ici2
      do j = jci1 , jci2
        tpred1(j,i,k) = coefe(j,i,k)*tpred1(j,i,k+1) + coeff1(j,i,k)
      end do
    end do
  end do
  !
  !   calculate tendency due to vertical diffusion using temporary
  !   predicted field
  !
  do k = 1 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        sf = (m2p%tatm(j,i,k)*m2p%psb(j,i))/m2p%thatm(j,i,k)
        p2m%difft(j,i,k) = p2m%difft(j,i,k) + &
                       (tpred1(j,i,k)-m2p%thatm(j,i,k))*rdt*sf
      end do
    end do
  end do
  !
  !   water vapor calculate coefficients at cross points for water vapor
  !
  do k = 2 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        betak(j,i,k) = rhohf(j,i,k-1)*kvq(j,i,k)/dza(j,i,k-1)
      end do
    end do
  end do

  do i = ici1 , ici2
    do j = jci1 , jci2
      coef1(j,i,1) = dt*alphak(j,i,1)*betak(j,i,2)
      coef2(j,i,1) = d_one + dt*alphak(j,i,1)*betak(j,i,2)
      coef3(j,i,1) = d_zero
      coefe(j,i,1) = coef1(j,i,1)/coef2(j,i,1)
      coeff1(j,i,1) = m2p%qxatm(j,i,1,iqv)/coef2(j,i,1)
    end do
  end do

  do k = 2 , kz - 1
    do i = ici1 , ici2
      do j = jci1 , jci2
        coef1(j,i,k) = dt*alphak(j,i,k)*betak(j,i,k+1)
        coef2(j,i,k) = d_one+dt*alphak(j,i,k)*(betak(j,i,k+1)+betak(j,i,k))
        coef3(j,i,k) = dt*alphak(j,i,k)*betak(j,i,k)
        coefe(j,i,k) = coef1(j,i,k)/(coef2(j,i,k)-coef3(j,i,k)*coefe(j,i,k-1))
        coeff1(j,i,k) = (m2p%qxatm(j,i,k,iqv)+coef3(j,i,k)*coeff1(j,i,k-1)) / &
                       (coef2(j,i,k)-coef3(j,i,k)*coefe(j,i,k-1))
      end do
    end do
  end do

  do i = ici1 , ici2
    do j = jci1 , jci2
      coef1(j,i,kz) = d_zero
      coef2(j,i,kz) = d_one + dt*alphak(j,i,kz)*betak(j,i,kz)
      coef3(j,i,kz) = dt*alphak(j,i,kz)*betak(j,i,kz)
      coefe(j,i,kz) = d_zero
      coeff1(j,i,kz) = (m2p%qxatm(j,i,kz,iqv) + &
               dt*alphak(j,i,kz)*m2p%qfx(j,i) + &
               coef3(j,i,kz)*coeff1(j,i,kz-1)) /    &
               (coef2(j,i,kz)-coef3(j,i,kz)*coefe(j,i,kz-1))
    end do
  end do
  !
  !   all coefficients have been computed, predict field and put it in
  !   temporary work space tpred
  !
  do i = ici1 , ici2
    do j = jci1 , jci2
      tpred1(j,i,kz) = coeff1(j,i,kz)
    end do
  end do

  do k = kz - 1 , 1 , -1
    do i = ici1 , ici2
      do j = jci1 , jci2
        tpred1(j,i,k) = coefe(j,i,k)*tpred1(j,i,k+1) + coeff1(j,i,k)
      end do
    end do
  end do
  !
  !   calculate tendency due to vertical diffusion using temporary
  !   predicted field
  !
  do k = 1 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        p2m%diffqx(j,i,k,iqv) = p2m%diffqx(j,i,k,iqv) + &
                     (tpred1(j,i,k)-m2p%qxatm(j,i,k,iqv))*rdt*m2p%psb(j,i)
      end do
    end do
  end do
  !
  !   calculate coefficients at cross points for cloud vater
  !
  do k = 2 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        betak(j,i,k) = rhohf(j,i,k-1)*kvq(j,i,k)/dza(j,i,k-1)
      end do
    end do
  end do
  do i = ici1 , ici2
    do j = jci1 , jci2
      coef1(j,i,1) = dt*alphak(j,i,1)*betak(j,i,2)
      coef2(j,i,1) = d_one + dt*alphak(j,i,1)*betak(j,i,2)
      coef3(j,i,1) = d_zero
      coefe(j,i,1) = coef1(j,i,1)/coef2(j,i,1)
      coeff1(j,i,1) = m2p%qxatm(j,i,1,iqc)/coef2(j,i,1)
    end do
  end do
  do k = 2 , kz - 1
    do i = ici1 , ici2
      do j = jci1 , jci2
        coef1(j,i,k) = dt*alphak(j,i,k)*betak(j,i,k+1)
        coef2(j,i,k) = d_one+dt*alphak(j,i,k)*(betak(j,i,k+1)+betak(j,i,k))
        coef3(j,i,k) = dt*alphak(j,i,k)*betak(j,i,k)
        coefe(j,i,k) = coef1(j,i,k)/(coef2(j,i,k)-coef3(j,i,k)*coefe(j,i,k-1))
        coeff1(j,i,k) = (m2p%qxatm(j,i,k,iqc)+coef3(j,i,k)*coeff1(j,i,k-1)) / &
                      (coef2(j,i,k)-coef3(j,i,k)*coefe(j,i,k-1))
      end do
    end do
  end do
  do i = ici1 , ici2
    do j = jci1 , jci2
      coef1(j,i,kz) = d_zero
      coef2(j,i,kz) = d_one + dt*alphak(j,i,kz)*betak(j,i,kz)
      coef3(j,i,kz) = dt*alphak(j,i,kz)*betak(j,i,kz)
      coefe(j,i,kz) = d_zero
      coeff1(j,i,kz) = (m2p%qxatm(j,i,kz,iqc) + &
              coef3(j,i,kz)*coeff1(j,i,kz-1)) / &
              (coef2(j,i,kz)-coef3(j,i,kz)*coefe(j,i,kz-1))
    end do
  end do
  !
  !   all coefficients have been computed, predict field and put it in
  !   temporary work space tpred
  !
  do i = ici1 , ici2
    do j = jci1 , jci2
      tpred1(j,i,kz) = coeff1(j,i,kz)
    end do
  end do
  do k = kz - 1 , 1 , -1
    do i = ici1 , ici2
      do j = jci1 , jci2
        tpred1(j,i,k) = coefe(j,i,k)*tpred1(j,i,k+1) + coeff1(j,i,k)
      end do
    end do
  end do
  !
  !   calculate tendency due to vertical diffusion using temporary
  !   predicted field
  !
  do k = 1 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        p2m%diffqx(j,i,k,iqc) = p2m%diffqx(j,i,k,iqc) + &
                    (tpred1(j,i,k)-m2p%qxatm(j,i,k,iqc))*rdt*m2p%psb(j,i)
      end do
    end do
  end do
!
! **********************************************************************
!
  !  now add countergradient term to temperature and water vapor equation
  !
  do i = ici1 , ici2
    do j = jci1 , jci2
      ttnp(j,i,1) = d_zero
    end do
  end do
  do k = 2 , kz
    do i = ici1 , ici2
      do j = jci1 , jci2
        sf = m2p%tatm(j,i,k)/m2p%thatm(j,i,k)
        ttnp(j,i,k) = sf*cpd*rhohf(j,i,k-1)*kvh(j,i,k)*cgh(j,i,k)
      end do
    end do
  end do
  !
  !   compute the tendencies:
  !
  do i = ici1 , ici2
    do j = jci1 , jci2
      p2m%difft(j,i,kz) = p2m%difft(j,i,kz) - hydf(kz)*ttnp(j,i,kz)*rcpd
    end do
  end do
  do k = 1 , kzm1
    do i = ici1 , ici2
      do j = jci1 , jci2
        p2m%difft(j,i,k) = p2m%difft(j,i,k) + &
                hydf(k)*(ttnp(j,i,k+1)-ttnp(j,i,k))*rcpd
      end do
    end do
  end do
  if ( ichem == 1 ) then
    !
    !     coef1, coef2, coef3 and coefe are the same as for water vapor
    !     and cloud water so they do not need to be recalculated
    !     recalculation of coef1,2,3  with tracer diffusivity kvc
    !
    do k = 2 , kz
      do i = ici1 , ici2
        do j = jci1 , jci2
          betak(j,i,k) = rhohf(j,i,k-1)*kvc(j,i,k)/dza(j,i,k-1)
        end do
      end do
    end do
    do k = 2 , kz - 1
      do i = ici1 , ici2
        do j = jci1 , jci2
          coef1(j,i,k) = dt*alphak(j,i,k)*betak(j,i,k+1)
          coef2(j,i,k) = d_one+dt*alphak(j,i,k)*(betak(j,i,k+1)+betak(j,i,k))
          coef3(j,i,k) = dt*alphak(j,i,k)*betak(j,i,k)
        end do
      end do
    end do
    do i = ici1 , ici2
      do j = jci1 , jci2
        coef1(j,i,1) = dt*alphak(j,i,1)*betak(j,i,2)
        coef2(j,i,1) = d_one + dt*alphak(j,i,1)*betak(j,i,2)
        coef3(j,i,1) = d_zero
        coef1(j,i,kz) = d_zero
        coef2(j,i,kz) = d_one + dt*alphak(j,i,kz)*betak(j,i,kz)
        coef3(j,i,kz) = dt*alphak(j,i,kz)*betak(j,i,kz)
      end do
    end do
    do itr = 1 , ntr
      do i = ici1 , ici2
        do j = jci1 , jci2
          coefe(j,i,1) = coef1(j,i,1)/coef2(j,i,1)
          coeff1(j,i,1) = m2p%chib(j,i,1,itr)/coef2(j,i,1)
        end do
      end do
      do k = 2 , kz - 1
        do i = ici1 , ici2
          do j = jci1 , jci2
            coefe(j,i,k) = coef1(j,i,k)/(coef2(j,i,k) - &
                           coef3(j,i,k)*coefe(j,i,k-1))
            coeff1(j,i,k) = (m2p%chib(j,i,k,itr) + &
                    coef3(j,i,k)*coeff1(j,i,k-1)) / &
                    (coef2(j,i,k)-coef3(j,i,k)*coefe(j,i,k-1))
          end do
        end do
      end do

      do i = ici1 , ici2
        do j = jci1 , jci2
          coefe(j,i,kz) = d_zero
          ! add dry deposition option1
          coeff1(j,i,kz) = (m2p%chib(j,i,kz,itr)-dt*alphak(j,i,kz) * &
                m2p%chib(j,i,kz,itr)*m2p%drydepv(j,i,itr)*m2p%rhox2d(j,i) + &
                coef3(j,i,kz)*coeff1(j,i,kz-1)) / &
                (coef2(j,i,kz)-coef3(j,i,kz)*coefe(j,i,kz-1))
        end do
      end do
      !
      !       all coefficients have been computed, predict field and put
      !       it in temporary work space tpred1
      !
      do i = ici1 , ici2
        do j = jci1 , jci2
          tpred1(j,i,kz) = coeff1(j,i,kz)
        end do
      end do
      do k = kz - 1 , 1 , -1
        do i = ici1 , ici2
          do j = jci1 , jci2
            tpred1(j,i,k) = coefe(j,i,k)*tpred1(j,i,k+1) + coeff1(j,i,k)
          end do
        end do
      end do
      !
      !       calculate tendency due to vertical diffusion using temporary
      !       predicted field
      !       Dry deposition option 1 is included
      !
      do k = 1 , kz
        do i = ici1 , ici2
          do j = jci1 , jci2
            p2m%chiten(j,i,k,itr) = p2m%chiten(j,i,k,itr) +  &
                        (tpred1(j,i,k)-m2p%chib(j,i,k,itr))*rdt*m2p%psb(j,i)
          end do
        end do
      end do
      do i = ici1 , ici2
        do j = jci1 , jci2
          p2m%remdrd(j,i,itr) = p2m%remdrd(j,i,itr) + m2p%chib(j,i,kz,itr)* &
              m2p%drydepv(j,i,itr)*m2p%psb(j,i)*dt*d_half*m2p%rhox2d(j,i)* &
              hydf(kz)/m2p%psb(j,i)

        end do
      end do
    end do
  end if
#ifdef DEBUG
  call time_end(subroutine_name,idindx)
#endif
  end subroutine holtbl
!
! ------------------------------------------------------------
! this routine computes the boundary layer eddy diffusivities
! for momentum, heat and moisture and the counter-gradient
! terms for heat and moisture.
!
! reference : holtslag, de bruijn and pan - mwr - 8/90
!
! input arguments :  j       longitudinal position index
!                    ubx3d   u wind component
!                    vbx3d   v wind component
!                    th3d    potential temperature
!                    thvx    virtual potential temperature
!                    za      height of half sigma levels
!                    f       coriolis parameter
!                    shum    specific humidity
!                    xhfx    sensible heat flux
!                    xqfx    sfc kinematic moisture flux
!                    th10    virt. pot. temp. at 10m
!                    hfxv    surface virtual heat flux
!                    obklen  monin obukov length
!                    ustr    friction velocity
!
! input/output
! arguments :        therm   thermal temperature excess
!
! output arguments : cgh     counter-gradient term for heat
!                    cgq     counter-gradient term for moisture
!                    kvm     eddy diffusivity for momentum
!                    kvh     eddy diffusivity for heat
!                    kvq     eddy diffusivity for moisture
!                   zpbl     boundary layer height
! ------------------------------------------------------------
!
  subroutine blhnew(m2p,p2m)
  implicit none
  type(mod_2_pbl) , intent(in) :: m2p
  type(pbl_2_mod) , intent(inout) :: p2m
  real(rk8) :: fak1 , fak2 , fht , xfmt , pblk , pblk1 , pblk2 , &
             phpblm , pr , therm2 , tkv , tlv , wsc , z , zh , &
             zl , zm , zp , zzh , zzhnew , zzhnew2
  integer(ik4) :: i , j , k , k2
#ifdef DEBUG
  character(len=dbgslen) :: subroutine_name = 'blhnew'
  integer(ik4) , save :: idindx = 0
  call time_begin(subroutine_name,idindx)
#endif
!
  ! note: kmxpbl, max no. of pbl levels, calculated in param
  ! compute richardson number
  do k = kz , kmxpbl , -1
    do i = ici1 , ici2
      do j = jci1 , jci2
        ri(j,i,k) = egrav*(thvx(j,i,k)-th10(j,i))*m2p%za(j,i,k) / &
                          (th10(j,i)*vv(j,i,k))
      end do
    end do
  end do
  ! first, set bl height to height of lowest model level
  do i = ici1 , ici2
    do j = jci1 , jci2
      p2m%zpbl(j,i) = m2p%za(j,i,kz)
      p2m%kpbl(j,i) = kz
    end do
  end do
  ! looking for bl top
  do k = kz , kmxpbl + 1 , -1
    k2 = k - 1
    do i = ici1 , ici2
      do j = jci1 , jci2
        ! bl height lies between this level and the last
        ! use linear interp. of rich. no. to height of ri=ricr
        if ( (ri(j,i,k) < ricr(j,i)) .and. (ri(j,i,k2) >= ricr(j,i)) ) then
          p2m%zpbl(j,i) = m2p%za(j,i,k) + (m2p%za(j,i,k2)-m2p%za(j,i,k)) &
              *((ricr(j,i)-ri(j,i,k))/(ri(j,i,k2)-ri(j,i,k)))
          p2m%kpbl(j,i) = k
        end if
      end do
    end do
  end do
  do i = ici1 , ici2
    do j = jci1 , jci2
      ! set bl top to highest allowable model layer
      if ( ri(j,i,kmxpbl) < ricr(j,i) ) then
        p2m%zpbl(j,i) = m2p%za(j,i,kmxpbl)
        p2m%kpbl(j,i) = kmxpbl
      end if
    end do
  end do
  ! recompute richardson no. at lowest model level
  do i = ici1 , ici2
    do j = jci1 , jci2
      if ( hfxv(j,i) > d_zero ) then
        ! estimate of convective velocity scale
        xfmt = (d_one-(binm*p2m%zpbl(j,i)/obklen(j,i)))**onet
        wsc = ustr(j,i)*xfmt
        ! thermal temperature excess
        therm(j,i) = (xhfx(j,i)+mult*m2p%thatm(j,i,kz)*xqfx(j,i))*fak/wsc
        ri(j,i,kz) = -egrav*therm(j,i)*m2p%za(j,i,kz)/(th10(j,i)*vv(j,i,kz))
      else
        therm(j,i) = d_zero
      end if
    end do
  end do
  ! recompute richardson no. at other model levels
  do k = kz - 1 , kmxpbl , -1
    do i = ici1 , ici2
      do j = jci1 , jci2
        if ( hfxv(j,i) > d_zero ) then
          tlv = th10(j,i) + therm(j,i)
          tkv = m2p%thatm(j,i,k)*(d_one+mult* &
                      (m2p%qxatm(j,i,k,iqv)/(m2p%qxatm(j,i,k,iqv)+d_one)))
          ri(j,i,k) = egrav*(tkv-tlv)*m2p%za(j,i,k)/(th10(j,i)*vv(j,i,k))
        end if
      end do
    end do
  end do
  ! improve estimate of bl height under convective conditions
  ! using convective temperature excess (therm)
  do k = kz , kmxpbl + 1 , -1
    k2 = k - 1
    do i = ici1 , ici2
      do j = jci1 , jci2
        if ( hfxv(j,i) > d_zero ) then
          ! bl height lies between this level and the last
          ! use linear interp. of rich. no. to height of ri=ricr
          if ( (ri(j,i,k) < ricr(j,i)) .and. (ri(j,i,k2) >= ricr(j,i)) ) then
            p2m%zpbl(j,i) = m2p%za(j,i,k) + (m2p%za(j,i,k2)-m2p%za(j,i,k)) * &
                        ((ricr(j,i)-ri(j,i,k))/(ri(j,i,k2)-ri(j,i,k)))
            p2m%kpbl(j,i) = k
          end if
        end if
      end do
    end do
  end do
  do i = ici1 , ici2
    do j = jci1 , jci2
      if ( hfxv(j,i) > d_zero ) then
        ! set bl top to highest allowable model layer
        if ( ri(j,i,kmxpbl) < ricr(j,i) ) then
          p2m%zpbl(j,i) = m2p%za(j,i,kmxpbl)
        end if
      end if
    end do
  end do
  ! limit bl height to be at least mech. mixing depth
  do i = ici1 , ici2
    do j = jci1 , jci2
      ! compute mechanical mixing depth, set to lowest model level if lower
      phpblm = 0.07D0*ustr(j,i)/pfcor(j,i)
      phpblm = dmax1(phpblm,m2p%za(j,i,kz))
      p2m%zpbl(j,i) = dmax1(p2m%zpbl(j,i),phpblm)
      p2m%kpbl(j,i) = kz
    end do
  end do

  do k = kz , kmxpbl + 1 , -1
    k2 = k - 1
    do i = ici1 , ici2
      do j = jci1 , jci2
        pblk = d_zero
        zm = m2p%za(j,i,k)
        zp = m2p%za(j,i,k2)
        if ( zm < p2m%zpbl(j,i) ) then
          zp = dmin1(zp,p2m%zpbl(j,i))
          z = (zm+zp)*d_half
          zh = z/p2m%zpbl(j,i)
          zl = z/obklen(j,i)
          if ( zh <= d_one ) then
            zzh = d_one - zh
            zzh = zzh**pink
!xexp4      zzhnew = p2m%zpbl(j,i)*(d_one-zh)*zh**1.5
!xexp5      zzhnew = 0.5*p2m%zpbl(j,i)*(d_one-zh)*zh**1.5
!xexp6      zzhnew = d_one - zh
!xexp7      zzhnew = 0.50 * (d_one - zh)
!Sara
!           zzhnew = 0.25 * (d_one - zh)
!           zzhnew = 0.75 * (d_one - zh)
!Sara_
!xexp10     zzhnew =zh * (d_one - zh)**2
            zzhnew = (d_one-zh)*zhnew_fac
            zzhnew2 = zzhnew**2
          else
            zzh = d_zero
            zzhnew = d_zero
            zzhnew2 = d_zero
          end if
          fak1 = ustr(j,i)*p2m%zpbl(j,i)*vonkar
          if ( hfxv(j,i) <= d_zero ) then
            ! stable and neutral conditions
            ! igroup = 1
            ! prevent pblk from becoming too small in very stable
            ! conditions
            if ( zl <= d_one ) then
              pblk = fak1*zh*zzh/(d_one+betas*zl)
!xexp5        pblk1 = vonkar * ustr(j,i) / (d_one+betas*zl) * zzhnew
              pblk1 = fak1*zh*zzhnew/(d_one+betas*zl)
              pblk2 = fak1*zh*zzhnew2/(d_one+betas*zl)
            else
              pblk = fak1*zh*zzh/(betas+zl)
!xexp5        pblk1 = vonkar * ustr(j,i) / (betas+zl) * zzhnew
              pblk1 = fak1*zh*zzhnew/(betas+zl)
              pblk2 = fak1*zh*zzhnew2/(betas+zl)
            end if
            ! compute eddy diffusivities
            kvm(j,i,k) = dmax1(pblk,kzo)
            kvh(j,i,k) = kvm(j,i,k)
            kvq(j,i,k) = dmax1(pblk1,kzo)
            ! Erika put k=0 in very stable conditions
            if ( zl <= 0.1D0 ) then
              kvm(j,i,k) = d_zero
              kvh(j,i,k) = kvm(j,i,k)*d_zero
              kvq(j,i,k) = d_zero
            end if
            ! Erika put k=0 in very stable conditions
            if ( ichem == 1 ) then
              kvc(j,i,k) = dmax1(pblk2,kzo)
            end if
            ! compute counter-gradient term
            cgh(j,i,k) = d_zero
          else
            ! unstable conditions
            ! compute counter gradient term
            if ( zh >= sffrac ) then
              ! igroup = 2
              xfmt = (d_one-binm*p2m%zpbl(j,i)/obklen(j,i))**onet
              fht = dsqrt(d_one-binh*p2m%zpbl(j,i)/obklen(j,i))
              wsc = ustr(j,i)*xfmt
              pr = (xfmt/fht) + ccon
              fak2 = wsc*p2m%zpbl(j,i)*vonkar
              pblk = fak2*zh*zzh
!xexp5        pblk1 = vonkar * wsc * zzhnew
              pblk1 = fak2*zh*zzhnew
              pblk2 = fak2*zh*zzhnew2
              therm2 = fak/(p2m%zpbl(j,i)*wsc)
              cgh(j,i,k) = hfxv(j,i)*therm2
            else
              ! igroup = 3
              pblk = fak1*zh*zzh*(d_one-betam*zl)**onet
!xexp5        pblk1 = vonkar * ustr(j,i) * zzhnew * (d_one-betam*zl)**onet
              pblk1 = fak1*zh*zzhnew*(d_one-betam*zl)**onet
              pblk2 = fak1*zh*zzhnew2*(d_one-betam*zl)**onet
              pr = ((d_one-betam*zl)**onet)/dsqrt(d_one-betah*zl)
              cgh(j,i,k) = d_zero
            end if
            ! compute eddy diffusivities
            kvm(j,i,k) = dmax1(pblk,kzo)
            kvh(j,i,k) = dmax1((pblk/pr),kzo)
            kvq(j,i,k) = dmax1(pblk1,kzo)
            if ( ichem == 1 ) then
              kvc(j,i,k) = dmax1(pblk2,kzo)
            end if
          end if
        end if
      end do
    end do
  end do

#ifdef DEBUG
  call time_end(subroutine_name,idindx)
#endif
  end subroutine blhnew
!
end module mod_pbl_holtbl
! vim: tabstop=8 expandtab shiftwidth=2 softtabstop=2
